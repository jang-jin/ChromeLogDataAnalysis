# -*- coding: utf-8 -*-
"""다운로드_목록_띄우기.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V3zwMbaPn3MiSo7QDMDMdPAtE9Vlhywa
"""



import sqlite3
conn = sqlite3.connect('/content/History')
c = conn.cursor()
QUERY = '''SELECT downloads.id, current_path, url, tab_url FROM downloads INNER JOIN downloads_url_chains'''
#id = 경로의 고유번호
# current_path = 현재 저장경로
# url = 실제 다운로드 링크
# tab_url = 참고링크
RESULT = c.execute(QUERY)
USER_INPUT = "ALZip1109"
SPLITED_PATH = Spliting_Path(RESULT)
ANSWER = CheckingPath_With_UserInput(USER_INPUT, SPLITED_PATH)
RESULT = c.execute(QUERY)
Printing_ReferenceLink_RealDownloadLink(ANSWER, RESULT)
conn.close()

# path만 따로 \로 나눠서 저장 나중에 입력과 비교하도록 나누기
def Spliting_Path(RESULT):
    splited_path = []
    for path_and_format in RESULT:
        splited_path.append(path_and_format[1].split('\\'))
    return splited_path

# User_Input과 일치하는 경로가 있는지 파악하는 함수
# User_Input = input(입력 : downloads 파일명, 경로)
def CheckingPath_With_UserInput(USER_INPUT, SPLITED_PATH):
    answer = []
    for data in SPLITED_PATH:
        for word in data:
            if USER_INPUT in word:
                joined_path = '\\'.join(data)
                if joined_path not in answer:
                    answer.append(joined_path)    
    return answer

# 일치하는 경로의 참고링크와 실제 다운로드 링크 출력하는 함수
def Printing_ReferenceLink_RealDownloadLink(ANSWER, RESULT):
    for Classification in RESULT:        
        if ANSWER[0] == Classification[1]:
            print("참고링크: " + Classification[3], "실제 다운로드 링크: " + Classification[2])

# conn.commit()